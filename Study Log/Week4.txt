25.02.10
C# Basic

/* HighLight :: 강사님의 조언
엔진 사용법을 배울 때 
플레이에 초점맞추지 말고 스크립트 로직에 대해 생각해라.
{
    Ex) 폭발음
    - 오브젝트에 컴포넌트를 배치했다면 
    인스턴스 삭제시 컴포넌트도 같이 삭제되어
    오디오가 재생되지 않음.
    
    ->  인스턴스 삭제 지연 처리 고려
    ->  인스턴스 위치를 가져와서
        빈 오브젝트 하위 컴포넌트로 오디오 등록하여 재생 후 삭제 
    
    --> 플레이어 인스턴스에 오디오를 등록
    --> 재생 위치벡터 보정 후 재생

    ====> 방법은 다양
    ====> 상황에 맞는 방법을 고려하고 구현 해보는 것이 중요하다.
} 
*/

#1 Lecture
C#도 GC가 존재하기 때문에 가상머신 안에서 돌아가는 언어다.
Serialize / DeSerialize
형식
File <- QueryLanguage -> Memory
블랙잭 - 프로그램의 생명 주기를 설명할 수 있는 대표적인 예시 프로그램

C :: RTTI : Run-Time Type Information :: C# Reflection

#2 Lecture
메모리 복습하기 
Code Area : 프로그램 실행 중에 변하지 않을 영역
Data Area : 런타임 중 실행 코드가 변할 수 있는 영역
Heap Area : 동적할당영역
Stack Area : 호출 영역

C#에서는 스택 영역에 값 형식 변수들이 생긴다
-> (int, float, bool, string, char, struct, stack)

Boxing - unBoxing 
(
    int c; 
    object d;
    d = c;
)

힙 영역 : 참조형(ref)
-> (class instance)
자료형 박싱에 대한 고찰글
https://cyphen156.tistory.com/217

#3 Lecture
Unity에서 Start()함수의 의미 == > 스크립트 로드 후 첫 프레임 렌더링 시 발동
==> Awake () Init
==> Enable () 렌더링 여부가 결정될 때
==> Start () 실제 렌더링 될 때
==> FixedUpdate () 프레임 속도와 무관하게 일정 주기마다 실행(물리연산)
==> Update () 프레임 마다 실행
==> LateUpdate() 카메라 움직임, 애니메이션 후처리 오브젝트 종속 업데이트
=====> 주로 보정 처리 관련해서 사용

카메라 옵션(투영)    : Perspective == 원근감
                    : orthographic == 원근감 없는 2D

{// 객체지향 프로그래밍의 핵심
    데이터 모델링
    FSM = 몬스터 행동을 제어하는 상태 머신
}

25.02.11
C# Basic
#1 Lecture
클래스를 만들 때 팁
클래스를 문장으로 만들었을 때 말이 되는가? 아닌가? 먼저 판단한다.

다형성 : virtual / override 
Monster monsters[] = new Monster[T];
Monster goblin = new Goblin();

goblin.Move(); 호출시 실행되는 코드에 대한 생각....
-> virtual 키워드 사용시 
--> Move()함수가 포인터 배열로 생성되기 때문에 성능에 영향이감

접근제한자와 상속에 관한 설명은 재산상속을 예로 들면 명확해진다.
Getter/Setter

// 변수는 노출시키지 않는다. 


25.02.12
Unity6 Basic
#1 Lecture
유니티 이벤트 시스템
인터페이스란 무엇인가?
// 이런거 있다 라는 선언문 ==> 있다고 했으니까 반드시 구현해야함
없으면? 컴파일러는 수렁에 빠진다....
사용법 : 상속키워드를 통해 사용
클래스 다이어그램 사용법 학습하기
인터페이스와 추상 클래스

#2 Lecture
Ipointer Interface
Unity의 EventSystems에서 기본적으로 제공되는 인터페이스
UI 오브젝트에는 graphic raycaster 컴포넌트가 추가되어있어야 합니디ㅏ.
raycaster Target또한 체크가 되어 있는 상태여야 한다.
2. Scene에는 EventSystems 컴포넌트가 반드시 필요하다
3. Object   작업 시에는 Collider컴포넌트와 
Main 카메라의 Physics raycaster컴포넌트가 추가되어 있어야 한다.

IPointerClickHandler :: 마우스를 클릭, 또는 터치할 때 한번 호출
누르고 난 뒤 뗄 때 한번 호출

IPointerDownHandler :: 누르는 순간 호출

IPointerUPHandler :: 뗄때 호출

IBeginDragHandler :: 드래그 진입시

IDragHandler :: 드래그 중일때 

#3 Lecture
Delegate  문법
변수에다가 함수를 집어넣음으로써 함수를 호출하기 위한 함수포인터
// 대리자 패턴
용법 : 
대리자명 변수명 = 대리자 인스턴스(등록될 함수이름);

사용시의 장점 : 코드간결성? 
대리자 패턴을 썻을 때 이득성은 타입이기 때문에 쓴다.
--> 매개변수/return으로 사용 -----> 함수포인터
메서드 체이닝 :: 연쇄 호출시
주의점 :: 함수를 추가/제거시 스택처럼 뒤에서 부터 제거하지만
실행은 스택이 아니라 큐다

추가된 메서드는 실행된다고 제거되지 않는다 
-> 이벤트 실행 후 직접 제거하지 않으면 
이전 이벤트가 여전히 남아있기 때문에 제거해주는 삭제 작업도 같이해야한다.
abstract 클래스 :: 추상메서드 ::> 추상클래스 || 유사 인터페이스

옵저버 패턴 :: 너와 나의 연결고리
니가 바뀌면 내가 가진 너에대한 정보도 업데이트
반대의 경우도 진행한다
이걸 왜쓰냐? 
-> 너가 없으면 나는 아무것도 못해 라는 기능이 있으면 안되니까

유니티 델리게이트 
1) Action action;   // 반환 타입이 없는 대리자
Action<T> action;   // 매개 변수가 있는 대리자

메서드 호출시 매개변수의 타입과 인자 수만 맞는다면 자동 타입 추론
하는 기능이 존재하지만
메서드 오버로딩시 매개변수의 순서가 중요해지기 때문에 같은 갯수, 타입을 순서만 바꿔서 전달하는 오버로딩은 피한다.

Example
public Study(int a, string str, char ch)
public Study( string str, char ch, int a)

Study study = new Study("sttttt", '1', 4)


2) Func<params..., return T> delegate    // 반환 타입이 있는 대리자

Func대리자의 경우 기능을 바로 구현해서 사용하는 것이 가능하다
=> 람다식
==> 쓰지마라
// 그래도 만드는 방법 정도는 알아두자
Func<int> test = () => 14;

Func<int> test = {
    return 14;
};

Func2<int> test = (a, b) => a + b;

만약 이렇게 두 개가 있다면 문제가 되지 않을까?
public Study(int a, string str, char ch) { }
public Study(char ch, int a, string str) { }

Study study = new Study("sttttt", '1', 4);

==>실제로 문제가 된다. 
MSDN에서는 명명된 인수와 선택적 인수를 통해 
자동타입 추론이 가능하다고 되어 있지만
실제로 유니티에서 사용시 에러가 발생한다.

Event Handler
이벤트는 특정 작업이 발생했음을 알려주는 기능
핸들러는 어떤 명령을 실행할 지 지정하는 것
대리자 패턴을 배운 이유

과제 :: 이벤트를 통해 플레이어가 죽었을 때의 시스템을 설계하시오.


25.02.13
Unity6 Basic
#1 Lecture
스크립터블 오브젝트
[CreateAssetMenu]
"ClassName":ScriptableObject
EmptyObject<ItemSampleSample><<newItemSample>>
SO/newItemSample

유니티에서 제공해주는 데이터 저장 객체
-> 게임 데이터를 관리하고 인스턴스끼리 공유할 수 있도록 도와줌

장점
동일한 오브젝트의 정보를 여러 오브젝트가 공유할 수 있도록 하고 메모리는 한번만 차지
데이터와 로직을 분리 사용
런타임 중 데이터 수정

단점
데이터 충돌 / 교착상태의 위험성
데이터 손실 위험성

데이터 베이스 없이 관리할 때 사용하기 좋음
행동패턴, 능력치 등에 대한 설정
게임의 설정 값 등에 사용하기 좋음

#2 Lecture
Data Structure
List
Dictionary
Queue
Stack
hashSet : 정렬 필요 없음, 데이터의 중복 없음

// 큐 : 중간에 있는 데이터를 접근하는게 비효율적이다.
Enqueue(data); -> 삽입
Dequeue() -> 삭제 // 맨 앞엣놈 하나 삭제
Peek() 맨 앞엣놈 제거안하고 가져오기
큐는 로컬 변수를 통해 제어하기 보다는 파일 리드를 통해 대화 묶음을 가지고 있는 편이 낫다

타이핑 텍스트
-> 화면 상에서 텍스트를 타이핑 하듯이 출력
...> 문자열 분할 출력
텍스트 UI에 만드세요

Push()
Pop()

#3Lecture
Quest System



25.02.14
Unity6 Basic
#1 Lecture
