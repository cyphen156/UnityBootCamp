25.04.14
Data Structure / Algorithms
#1 Lecture
지난주 Review
리스트란 무엇인가?
Linear / Linked 둘의 가장 큰 차이점은 ??? 
-> 메모리 적재시 위치가 달라짐
--> 인접 위치   /   Random
--> 지역성      /   Reference
=> 데이터를 가져 올 때 워드 단위로 가져온다 --> 캐시 Hit / Miss에 가장 큰 차이가 생김

Cache란 무엇인가?
시간복잡도란 무었인가?
그렇다면 자료구조는 왜 만드나?
데이터를 조직화 한다. ==> 데이터를 해석하는 방법을 만든다.

<스택>
Push()
Pop()
Peek()
시간복잡도 성능은 항상 O(1)
삽입 위치, 삭제 위치가 항상 같기 때문에

시작시 top의 위치는 어디인가?
--> 0번 아직 아무런 자료도 입력되지 않았기 때문에
==> 자료가 삽입 되면서 Top의 위치가 변화한다.


스택을 연결리스트로 만든다고 가정했을 때 이중 연결리스트를 사용할 것인가? 아니면 단일 연결리스트를 사용할것인가?
궂이 이중연결리스트를 사용해야하나?
스택은 항상 실행 위치가 정해져있다.
--> 메모리상 크기가 달라지고, Push, Pop시 실행 속도가 달라진다.
근데?? 스택을 사용하는 이유는 적은 메모리를 사용하고, 빠른 실행 속도가 보장되기 때문에 사용한다.
-----> 궂이 이중 연결 리스트를 사용할 필요가 없다.


내가 스택을 구현할 때 선형리스트가 아닌 연결 리스트를 선택한 이유
어차피 자료의 삽입, 삭제와 같은 수행 위치는 항상 정해져 있으니 수행시간은 고려가 되지 않는다. 
하지만 자료를 삽입 할 때 섢형 리스트를 배열로 구현한다고 가정하면 Size를 넘어갈 때마다 재할당이 일어나기 때문에 나는 연결 리스트를로 자료를 구현할 것 같다.

진짜 그러한가?
선형 자료구조로 스택을 구현하면 저 사이즈 재할당보다 이득이 될 수 잇는가? 지역성 문제로 인한 메모리 히트 접근 시간을 고려 한다면?

캐시 히트 / 미스 할 때 고려해야 할 상황은 배열 재할당시 접근 속도보다 훨씬 중요하다.
다시 생각해보면  Push할 때 에만 발생하는 가능성, 그리고 매우 제한적으로 발생하는 재할당 상황
Pop시에는 그냥 잇는 배열에서 스택의 Top 인덱스를 줄이기만 하면 되므로 훨씬 수행속도가 빠르다


#2 Lecture
클래스란 무엇인가...?
모듈화의 기본은 잘 동작하고 있는 것을 잘 파편으로 나누는 것 
이런 저런 시도해보며 부딪히고 머리박아봐라

합타입 / 곱타입

#3 Lecture (FIFO)
힙은 대표적인 선입 선출
배열로 구현한다면 
[front][][][][][][][][rear]
[][front][][][][][][][rear]
[][][][][][][][][front / rear]

// 만약 초기 사이즈를 넘어 섯다
Case By 1. front가 초기값이 아니다.
==> 앞으로 땡겨 올 수 있다.
====>? 언제 땡겨올지는 알아서 정해라
But 반드시 땡겨올 타이밍은 front / rear가 맞다을 시 반드시 땡겨온다.
if (삽입이 빈번하지 않을 때는)
&& 
front가 절반 이상 넘어갓고, rear가 배열의 마지막 요소에 도달했을 때와 같은 상황이 발생하면 땡겨온다.
[front][][][][][][][][rear]
[][front][][][][][][][rear]
[][][][][][][][][front / rear]
[front / rear][][][][][][][][]

Case By 2. front가 초깃값인데 Rear가 맨 끝에 도달하고도 삽입이 일어난다.
==> 배열 인덱스를 넘어간다 
====> 배열을 늘리자!
[front][][][][][][][][rear]
[front][][][][][][][][rear][][][][][][][][][]
[front][][][][][][][][][][][rear][][][][][][]
[][][][][][front][][][][][][rear][][][][][][]


Case By3. 배열에서도 원형 큐 가능하다
front와 rear --> front가 dequeue 되어있는 상황으로 비어 있을 때 그 공간을 리어로 사용할 수 있음 
// 이 경우 전체 배열 크기에 대한 정보를 가지고 인덱스 초과시 초기 인덱스부터 front까지 순환 탐색하는 과정 발생
[front][][][][][][][][rear]
[][front][][][][][][][rear]
[rear][front][][][][][][][]
[][][rear][][front][][][][]


25.04.15
Data Structure / Algorithms
#1 Lecture
Stack / Queue 복습하기
객체란 무엇인가????
=> 행위의 주체, 명령을 내렸을 때 실행하는 것이 누구인가?

SOLID

S => Single Responsibility Principle
==> 너는 다른거 하지말고 니 할 일만 해라! 


25.04.16
Unity6 Deep
#1 Lecture
PlayerStateManager
GameManager
상점

25.04.17
Unity6 Deep
#1 Lecture



25.04.18
Unity6 Deep
#1 Lecture


